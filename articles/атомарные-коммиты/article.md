#Совет разработчика: делайте "атомарные коммиты" (перевод)

Контроль исходного кода - лучший друг разработчика. Возможности поделиться кодом с другими разработчиками, отслеживать изменения и возможность легко откатиться назад, когда возникают проблемы, необходимы в распределенном мире.

Вопрос, который часто возникает при начале работы с системами контроля версий (независимо, что вы используете: Git, SVN, TFS и др.) -  "Какие изменения фиксировать и как часто это делать?". Мой ответ - делать изменения настолько малыми и "атомарными" насколько возможно.

##"Атомарные" коммиты.

"Атомарные" изменения производятся для одной задачи или одного исправления.

Я получил письмо со списком изменений макета и исправлениями багов, которые нужно сделать в веб-приложении, над которым я работаю. Все эти изменения очень простые. Один из подходов был в том, чтобы сделать все простые изменения/исправления, закоммитить их в репозитории и закончить с этим. Однако, что произойдет, если исправления багов вызовут другие ошибки или не решат проблему на самом деле?

Лучшие практики говорят, что вы должны откатить назад свой текущий коммит, сделать правильные исправления и затем закоммитить изменения/исправления снова. Однако, если бы вы так сделали, вы потеряли бы все изменения макета (которые работали хорошо) и вы бы делали дополнительную работу по повторному применению изменений макета. Дополнительно, создание коммита "исправление исправления багов" - не очень хороший подход.

Вместо этого можно сделать один коммит для исправления ошибок и еще один коммит для изменения макета. В таком случае легко откатиться назад в исправлении ошибок без отката изменений макета. Я бы даже сказал, что стоит делать коммиты каждого изменения макета, потому что это упрощает изменение макета на лету или легко откатить назад изменение цвета без влияния на другие связанные изменения.

Когда разрабатываются новые функции, атомарные коммиты будут часто содержать множество файлов: файл макета, behind-код файлы и дополнительные ресурсы, которые могут быть добавлены/модифицированы. Вы не захотите коммитить всех эти файлы отдельно, потому что если вы откатите приложения к состоянию до того, как была добавлена функция, это затронет множество коммитов и может привести к путанице. Также это поможет при слиянии с другими ветками, потому что Вы можете легко выбрать единственный коммит для слияния и все связанные файлы будут объединены. Я использовал это несколько раз с большим успехом.

Обычные мысли новичков при работе с контролем исходного кода - это коммитить "в конце рабочего для" или "каждый раз, когда я захочу" или каждый раз, когда партия исправлений готова. Избегайте этого и учитывайте, что такое "атомарный" блок работы и выполняйте коммит только когда он завершен. Это может сделать вашу историю коммитов более многословной, но в конце концов это сделает ваш проект более гибким для исправления ошибок, миграций функций и откатов.

###Атомарный подход
- Делать коммиты каждого исправления или задачи отдельно
- Делать коммит только когда блок работы завершен
- Делать коммит каждого изменения макета отдельно
- Включать в коммит файлы макета, файлы behind-кода и дополнительные ресурсы

###Преимущества
- Легкий откат без влияния на другие изменения
- Легко делать другие изменения на лету
- Легко сливать функции в другие ветки

[Оригинальная статья: Developer tip: keep your commits “atomics”. Sean Patterson](http://www.freshconsulting.com/atomic-commits/)
